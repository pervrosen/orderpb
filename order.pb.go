// Code generated by protoc-gen-go. DO NOT EDIT.
// source: order.proto

package orderpb

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type NewOrderMessage struct {
	Symbol               string   `protobuf:"bytes,1,opt,name=Symbol,proto3" json:"Symbol,omitempty"`
	Trader               string   `protobuf:"bytes,2,opt,name=Trader,proto3" json:"Trader,omitempty"`
	Side                 int32    `protobuf:"varint,3,opt,name=Side,proto3" json:"Side,omitempty"`
	Price                float32  `protobuf:"fixed32,4,opt,name=Price,proto3" json:"Price,omitempty"`
	Size                 int32    `protobuf:"varint,5,opt,name=Size,proto3" json:"Size,omitempty"`
	OrderID              int32    `protobuf:"varint,6,opt,name=OrderID,proto3" json:"OrderID,omitempty"`
	TimeOfEntry          string   `protobuf:"bytes,7,opt,name=TimeOfEntry,proto3" json:"TimeOfEntry,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NewOrderMessage) Reset()         { *m = NewOrderMessage{} }
func (m *NewOrderMessage) String() string { return proto.CompactTextString(m) }
func (*NewOrderMessage) ProtoMessage()    {}
func (*NewOrderMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd01338c35d87077, []int{0}
}

func (m *NewOrderMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NewOrderMessage.Unmarshal(m, b)
}
func (m *NewOrderMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NewOrderMessage.Marshal(b, m, deterministic)
}
func (m *NewOrderMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewOrderMessage.Merge(m, src)
}
func (m *NewOrderMessage) XXX_Size() int {
	return xxx_messageInfo_NewOrderMessage.Size(m)
}
func (m *NewOrderMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_NewOrderMessage.DiscardUnknown(m)
}

var xxx_messageInfo_NewOrderMessage proto.InternalMessageInfo

func (m *NewOrderMessage) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *NewOrderMessage) GetTrader() string {
	if m != nil {
		return m.Trader
	}
	return ""
}

func (m *NewOrderMessage) GetSide() int32 {
	if m != nil {
		return m.Side
	}
	return 0
}

func (m *NewOrderMessage) GetPrice() float32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *NewOrderMessage) GetSize() int32 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *NewOrderMessage) GetOrderID() int32 {
	if m != nil {
		return m.OrderID
	}
	return 0
}

func (m *NewOrderMessage) GetTimeOfEntry() string {
	if m != nil {
		return m.TimeOfEntry
	}
	return ""
}

type OrderBookInfoMessage struct {
	OrderBookString      string   `protobuf:"bytes,1,opt,name=OrderBookString,proto3" json:"OrderBookString,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OrderBookInfoMessage) Reset()         { *m = OrderBookInfoMessage{} }
func (m *OrderBookInfoMessage) String() string { return proto.CompactTextString(m) }
func (*OrderBookInfoMessage) ProtoMessage()    {}
func (*OrderBookInfoMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd01338c35d87077, []int{1}
}

func (m *OrderBookInfoMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OrderBookInfoMessage.Unmarshal(m, b)
}
func (m *OrderBookInfoMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OrderBookInfoMessage.Marshal(b, m, deterministic)
}
func (m *OrderBookInfoMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBookInfoMessage.Merge(m, src)
}
func (m *OrderBookInfoMessage) XXX_Size() int {
	return xxx_messageInfo_OrderBookInfoMessage.Size(m)
}
func (m *OrderBookInfoMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBookInfoMessage.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBookInfoMessage proto.InternalMessageInfo

func (m *OrderBookInfoMessage) GetOrderBookString() string {
	if m != nil {
		return m.OrderBookString
	}
	return ""
}

type PingMessage struct {
	Greeting             string   `protobuf:"bytes,1,opt,name=greeting,proto3" json:"greeting,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PingMessage) Reset()         { *m = PingMessage{} }
func (m *PingMessage) String() string { return proto.CompactTextString(m) }
func (*PingMessage) ProtoMessage()    {}
func (*PingMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd01338c35d87077, []int{2}
}

func (m *PingMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PingMessage.Unmarshal(m, b)
}
func (m *PingMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PingMessage.Marshal(b, m, deterministic)
}
func (m *PingMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PingMessage.Merge(m, src)
}
func (m *PingMessage) XXX_Size() int {
	return xxx_messageInfo_PingMessage.Size(m)
}
func (m *PingMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_PingMessage.DiscardUnknown(m)
}

var xxx_messageInfo_PingMessage proto.InternalMessageInfo

func (m *PingMessage) GetGreeting() string {
	if m != nil {
		return m.Greeting
	}
	return ""
}

type TraderInfoMessage struct {
	Trader               string   `protobuf:"bytes,1,opt,name=Trader,proto3" json:"Trader,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TraderInfoMessage) Reset()         { *m = TraderInfoMessage{} }
func (m *TraderInfoMessage) String() string { return proto.CompactTextString(m) }
func (*TraderInfoMessage) ProtoMessage()    {}
func (*TraderInfoMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd01338c35d87077, []int{3}
}

func (m *TraderInfoMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TraderInfoMessage.Unmarshal(m, b)
}
func (m *TraderInfoMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TraderInfoMessage.Marshal(b, m, deterministic)
}
func (m *TraderInfoMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TraderInfoMessage.Merge(m, src)
}
func (m *TraderInfoMessage) XXX_Size() int {
	return xxx_messageInfo_TraderInfoMessage.Size(m)
}
func (m *TraderInfoMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_TraderInfoMessage.DiscardUnknown(m)
}

var xxx_messageInfo_TraderInfoMessage proto.InternalMessageInfo

func (m *TraderInfoMessage) GetTrader() string {
	if m != nil {
		return m.Trader
	}
	return ""
}

type ItemQueryMessage struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ItemQueryMessage) Reset()         { *m = ItemQueryMessage{} }
func (m *ItemQueryMessage) String() string { return proto.CompactTextString(m) }
func (*ItemQueryMessage) ProtoMessage()    {}
func (*ItemQueryMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd01338c35d87077, []int{4}
}

func (m *ItemQueryMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ItemQueryMessage.Unmarshal(m, b)
}
func (m *ItemQueryMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ItemQueryMessage.Marshal(b, m, deterministic)
}
func (m *ItemQueryMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemQueryMessage.Merge(m, src)
}
func (m *ItemQueryMessage) XXX_Size() int {
	return xxx_messageInfo_ItemQueryMessage.Size(m)
}
func (m *ItemQueryMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemQueryMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ItemQueryMessage proto.InternalMessageInfo

func (m *ItemQueryMessage) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

type TradeMessage struct {
	TimeOfEntry          string   `protobuf:"bytes,1,opt,name=TimeOfEntry,proto3" json:"TimeOfEntry,omitempty"`
	Trader               string   `protobuf:"bytes,2,opt,name=Trader,proto3" json:"Trader,omitempty"`
	Size                 int32    `protobuf:"varint,3,opt,name=Size,proto3" json:"Size,omitempty"`
	Symbol               string   `protobuf:"bytes,4,opt,name=Symbol,proto3" json:"Symbol,omitempty"`
	Price                float32  `protobuf:"fixed32,5,opt,name=Price,proto3" json:"Price,omitempty"`
	OrderID              int32    `protobuf:"varint,6,opt,name=OrderID,proto3" json:"OrderID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TradeMessage) Reset()         { *m = TradeMessage{} }
func (m *TradeMessage) String() string { return proto.CompactTextString(m) }
func (*TradeMessage) ProtoMessage()    {}
func (*TradeMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd01338c35d87077, []int{5}
}

func (m *TradeMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TradeMessage.Unmarshal(m, b)
}
func (m *TradeMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TradeMessage.Marshal(b, m, deterministic)
}
func (m *TradeMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradeMessage.Merge(m, src)
}
func (m *TradeMessage) XXX_Size() int {
	return xxx_messageInfo_TradeMessage.Size(m)
}
func (m *TradeMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_TradeMessage.DiscardUnknown(m)
}

var xxx_messageInfo_TradeMessage proto.InternalMessageInfo

func (m *TradeMessage) GetTimeOfEntry() string {
	if m != nil {
		return m.TimeOfEntry
	}
	return ""
}

func (m *TradeMessage) GetTrader() string {
	if m != nil {
		return m.Trader
	}
	return ""
}

func (m *TradeMessage) GetSize() int32 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *TradeMessage) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *TradeMessage) GetPrice() float32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *TradeMessage) GetOrderID() int32 {
	if m != nil {
		return m.OrderID
	}
	return 0
}

type TradeMatchingMessage struct {
	TimeOfEntry          string   `protobuf:"bytes,1,opt,name=timeOfEntry,proto3" json:"timeOfEntry,omitempty"`
	Size                 int32    `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	Symbol               string   `protobuf:"bytes,3,opt,name=symbol,proto3" json:"symbol,omitempty"`
	Price                float32  `protobuf:"fixed32,4,opt,name=price,proto3" json:"price,omitempty"`
	TraderBid            string   `protobuf:"bytes,5,opt,name=traderBid,proto3" json:"traderBid,omitempty"`
	OrderIDBid           int32    `protobuf:"varint,6,opt,name=orderIDBid,proto3" json:"orderIDBid,omitempty"`
	TraderAsk            string   `protobuf:"bytes,7,opt,name=traderAsk,proto3" json:"traderAsk,omitempty"`
	OrderIDAsk           int32    `protobuf:"varint,8,opt,name=orderIDAsk,proto3" json:"orderIDAsk,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TradeMatchingMessage) Reset()         { *m = TradeMatchingMessage{} }
func (m *TradeMatchingMessage) String() string { return proto.CompactTextString(m) }
func (*TradeMatchingMessage) ProtoMessage()    {}
func (*TradeMatchingMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd01338c35d87077, []int{6}
}

func (m *TradeMatchingMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TradeMatchingMessage.Unmarshal(m, b)
}
func (m *TradeMatchingMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TradeMatchingMessage.Marshal(b, m, deterministic)
}
func (m *TradeMatchingMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradeMatchingMessage.Merge(m, src)
}
func (m *TradeMatchingMessage) XXX_Size() int {
	return xxx_messageInfo_TradeMatchingMessage.Size(m)
}
func (m *TradeMatchingMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_TradeMatchingMessage.DiscardUnknown(m)
}

var xxx_messageInfo_TradeMatchingMessage proto.InternalMessageInfo

func (m *TradeMatchingMessage) GetTimeOfEntry() string {
	if m != nil {
		return m.TimeOfEntry
	}
	return ""
}

func (m *TradeMatchingMessage) GetSize() int32 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *TradeMatchingMessage) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *TradeMatchingMessage) GetPrice() float32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *TradeMatchingMessage) GetTraderBid() string {
	if m != nil {
		return m.TraderBid
	}
	return ""
}

func (m *TradeMatchingMessage) GetOrderIDBid() int32 {
	if m != nil {
		return m.OrderIDBid
	}
	return 0
}

func (m *TradeMatchingMessage) GetTraderAsk() string {
	if m != nil {
		return m.TraderAsk
	}
	return ""
}

func (m *TradeMatchingMessage) GetOrderIDAsk() int32 {
	if m != nil {
		return m.OrderIDAsk
	}
	return 0
}

func init() {
	proto.RegisterType((*NewOrderMessage)(nil), "orderpb.NewOrderMessage")
	proto.RegisterType((*OrderBookInfoMessage)(nil), "orderpb.OrderBookInfoMessage")
	proto.RegisterType((*PingMessage)(nil), "orderpb.PingMessage")
	proto.RegisterType((*TraderInfoMessage)(nil), "orderpb.TraderInfoMessage")
	proto.RegisterType((*ItemQueryMessage)(nil), "orderpb.ItemQueryMessage")
	proto.RegisterType((*TradeMessage)(nil), "orderpb.TradeMessage")
	proto.RegisterType((*TradeMatchingMessage)(nil), "orderpb.TradeMatchingMessage")
}

func init() {
	proto.RegisterFile("order.proto", fileDescriptor_cd01338c35d87077)
}

var fileDescriptor_cd01338c35d87077 = []byte{
	// 589 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x95, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xc7, 0x63, 0x37, 0x6e, 0x92, 0x31, 0xb4, 0x65, 0x15, 0x90, 0x89, 0x28, 0x8a, 0xf6, 0x14,
	0x84, 0x14, 0xa1, 0xc0, 0x0d, 0x0e, 0x6d, 0x08, 0x44, 0x91, 0x08, 0x29, 0x49, 0x4f, 0x1c, 0x90,
	0x9c, 0x78, 0x1b, 0xac, 0x34, 0xde, 0x68, 0xbd, 0x15, 0x4a, 0x9e, 0x87, 0xb7, 0xe0, 0x5d, 0x78,
	0x0c, 0xce, 0x68, 0x3f, 0x6c, 0x6f, 0x9c, 0x8f, 0x8b, 0x4f, 0xf5, 0xfc, 0x77, 0x66, 0xf6, 0x37,
	0x33, 0x3b, 0x0d, 0xb8, 0x94, 0x05, 0x84, 0xb5, 0x57, 0x8c, 0x72, 0x8a, 0x2a, 0xd2, 0x58, 0x4d,
	0xf1, 0x1f, 0x0b, 0xce, 0xbf, 0x92, 0x5f, 0x23, 0x61, 0x0e, 0x49, 0x1c, 0xfb, 0x73, 0x82, 0x9e,
	0xc1, 0xe9, 0x64, 0xbd, 0x9c, 0xd2, 0x7b, 0xcf, 0x6a, 0x5a, 0xad, 0xda, 0x58, 0x5b, 0x42, 0xbf,
	0x65, 0x7e, 0x40, 0x98, 0x67, 0x2b, 0x5d, 0x59, 0x08, 0x41, 0x79, 0x12, 0x06, 0xc4, 0x3b, 0x69,
	0x5a, 0x2d, 0x67, 0x2c, 0xbf, 0x51, 0x1d, 0x9c, 0x1b, 0x16, 0xce, 0x88, 0x57, 0x6e, 0x5a, 0x2d,
	0x7b, 0xac, 0x0c, 0xe5, 0xb9, 0x21, 0x9e, 0x93, 0x78, 0x6e, 0x08, 0xf2, 0xa0, 0x22, 0x6f, 0x1f,
	0xf4, 0xbc, 0x53, 0x29, 0x27, 0x26, 0x6a, 0x82, 0x7b, 0x1b, 0x2e, 0xc9, 0xe8, 0xee, 0x53, 0xc4,
	0xd9, 0xda, 0xab, 0xc8, 0x4b, 0x4d, 0x09, 0x5f, 0x41, 0x5d, 0x3a, 0x77, 0x29, 0x5d, 0x0c, 0xa2,
	0x3b, 0x9a, 0x54, 0xd0, 0x82, 0xf3, 0x54, 0x9f, 0x70, 0x16, 0x46, 0x73, 0x5d, 0x4a, 0x5e, 0xc6,
	0xaf, 0xc0, 0xbd, 0x09, 0xa3, 0x79, 0x12, 0xd8, 0x80, 0xea, 0x9c, 0x11, 0xc2, 0xb3, 0x88, 0xd4,
	0xc6, 0xaf, 0xe1, 0x89, 0x2a, 0xd8, 0xbc, 0x29, 0xeb, 0x89, 0x65, 0xf6, 0x04, 0x63, 0xb8, 0x18,
	0x70, 0xb2, 0xfc, 0xf6, 0x40, 0xd8, 0x3a, 0xf1, 0x3d, 0x03, 0x7b, 0xd0, 0x93, 0x7e, 0xce, 0xd8,
	0x1e, 0xf4, 0xf0, 0x6f, 0x0b, 0x1e, 0x49, 0xf7, 0xc4, 0x21, 0x57, 0xb0, 0xb5, 0x53, 0xf0, 0xf1,
	0x11, 0x6c, 0x8c, 0x11, 0x6c, 0xcc, 0x31, 0x96, 0xb7, 0xc6, 0x98, 0x8e, 0xc6, 0x31, 0x47, 0x73,
	0x70, 0x0c, 0xf8, 0x9f, 0x05, 0x75, 0x85, 0xe9, 0xf3, 0xd9, 0x4f, 0xa3, 0x59, 0x4d, 0x70, 0xf9,
	0x2e, 0xae, 0x21, 0x09, 0xac, 0x58, 0x60, 0xd9, 0x0a, 0x2b, 0xd6, 0x58, 0xb1, 0xc2, 0x3a, 0x51,
	0x58, 0x71, 0x8a, 0xb5, 0x32, 0x5f, 0x8c, 0x34, 0xd0, 0x0b, 0xa8, 0x71, 0x59, 0x62, 0x37, 0x0c,
	0x24, 0x70, 0x6d, 0x9c, 0x09, 0xe8, 0x25, 0x00, 0x55, 0x94, 0xe2, 0x58, 0x71, 0x1b, 0x4a, 0x16,
	0x7d, 0x1d, 0x2f, 0xf4, 0xfb, 0xc9, 0x04, 0x23, 0x5a, 0x1c, 0x57, 0xb7, 0xa2, 0xaf, 0xe3, 0x45,
	0xe7, 0xaf, 0x0d, 0x8e, 0x6c, 0x02, 0xba, 0x82, 0xaa, 0x1f, 0x04, 0xea, 0xdb, 0x6b, 0xeb, 0xdd,
	0x69, 0xe7, 0xf6, 0xa6, 0x71, 0xf0, 0x04, 0x97, 0x44, 0x86, 0x39, 0xe1, 0x45, 0x32, 0x7c, 0x04,
	0xf7, 0x61, 0x15, 0xf8, 0x9c, 0x14, 0x4c, 0x32, 0xf3, 0xa3, 0x19, 0xb9, 0x2f, 0x92, 0xa4, 0x0f,
	0x67, 0x2b, 0x16, 0x46, 0xaa, 0x9a, 0x29, 0xa5, 0x0b, 0x54, 0x4f, 0xbd, 0x8d, 0x65, 0x6a, 0x5c,
	0xa6, 0xea, 0xbe, 0x25, 0xc5, 0xa5, 0xce, 0x07, 0x28, 0x0b, 0x7f, 0xf4, 0x4e, 0xff, 0xdd, 0x9f,
	0x66, 0xaf, 0x8a, 0x4b, 0x9d, 0x09, 0xd4, 0xfa, 0xba, 0xa5, 0x31, 0xfa, 0x6c, 0x1a, 0x8d, 0x34,
	0x62, 0x67, 0x61, 0x1b, 0xcf, 0xd3, 0xb3, 0xfc, 0x7e, 0xe2, 0xd2, 0x1b, 0xab, 0x33, 0xca, 0xf2,
	0x74, 0x50, 0xd7, 0x34, 0x0e, 0x07, 0x1e, 0x6b, 0x96, 0xa6, 0x94, 0x1c, 0x09, 0xa5, 0x36, 0x0a,
	0x50, 0x7e, 0x81, 0x6a, 0x92, 0x47, 0xbc, 0xac, 0xf4, 0xfb, 0x08, 0xe3, 0xd3, 0xed, 0xdb, 0xcc,
	0x6c, 0x3e, 0x5c, 0xf4, 0x09, 0x97, 0xdb, 0x4d, 0x02, 0x0d, 0x37, 0xdc, 0xa3, 0x15, 0x00, 0xfe,
	0x01, 0x8f, 0x13, 0x48, 0x99, 0x13, 0x0d, 0xf3, 0xc2, 0x11, 0xf4, 0xcb, 0x1c, 0xfa, 0xf6, 0xbf,
	0x21, 0x91, 0xbf, 0xeb, 0x7e, 0xaf, 0xb5, 0xdf, 0x6b, 0xaf, 0xe9, 0xa9, 0xfc, 0x8d, 0x7b, 0xfb,
	0x3f, 0x00, 0x00, 0xff, 0xff, 0x45, 0x90, 0xaa, 0x74, 0xf2, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// OrderClient is the client API for Order service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type OrderClient interface {
	AddOrder(ctx context.Context, in *NewOrderMessage, opts ...grpc.CallOption) (*NewOrderMessage, error)
	GetOrder(ctx context.Context, in *NewOrderMessage, opts ...grpc.CallOption) (*NewOrderMessage, error)
	UpdateOrder(ctx context.Context, in *NewOrderMessage, opts ...grpc.CallOption) (*NewOrderMessage, error)
	CancelOrder(ctx context.Context, in *NewOrderMessage, opts ...grpc.CallOption) (*NewOrderMessage, error)
	PrintOrderbook(ctx context.Context, in *PingMessage, opts ...grpc.CallOption) (*OrderBookInfoMessage, error)
}

type orderClient struct {
	cc grpc.ClientConnInterface
}

func NewOrderClient(cc grpc.ClientConnInterface) OrderClient {
	return &orderClient{cc}
}

func (c *orderClient) AddOrder(ctx context.Context, in *NewOrderMessage, opts ...grpc.CallOption) (*NewOrderMessage, error) {
	out := new(NewOrderMessage)
	err := c.cc.Invoke(ctx, "/orderpb.Order/addOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderClient) GetOrder(ctx context.Context, in *NewOrderMessage, opts ...grpc.CallOption) (*NewOrderMessage, error) {
	out := new(NewOrderMessage)
	err := c.cc.Invoke(ctx, "/orderpb.Order/getOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderClient) UpdateOrder(ctx context.Context, in *NewOrderMessage, opts ...grpc.CallOption) (*NewOrderMessage, error) {
	out := new(NewOrderMessage)
	err := c.cc.Invoke(ctx, "/orderpb.Order/updateOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderClient) CancelOrder(ctx context.Context, in *NewOrderMessage, opts ...grpc.CallOption) (*NewOrderMessage, error) {
	out := new(NewOrderMessage)
	err := c.cc.Invoke(ctx, "/orderpb.Order/cancelOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orderClient) PrintOrderbook(ctx context.Context, in *PingMessage, opts ...grpc.CallOption) (*OrderBookInfoMessage, error) {
	out := new(OrderBookInfoMessage)
	err := c.cc.Invoke(ctx, "/orderpb.Order/printOrderbook", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OrderServer is the server API for Order service.
type OrderServer interface {
	AddOrder(context.Context, *NewOrderMessage) (*NewOrderMessage, error)
	GetOrder(context.Context, *NewOrderMessage) (*NewOrderMessage, error)
	UpdateOrder(context.Context, *NewOrderMessage) (*NewOrderMessage, error)
	CancelOrder(context.Context, *NewOrderMessage) (*NewOrderMessage, error)
	PrintOrderbook(context.Context, *PingMessage) (*OrderBookInfoMessage, error)
}

// UnimplementedOrderServer can be embedded to have forward compatible implementations.
type UnimplementedOrderServer struct {
}

func (*UnimplementedOrderServer) AddOrder(ctx context.Context, req *NewOrderMessage) (*NewOrderMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddOrder not implemented")
}
func (*UnimplementedOrderServer) GetOrder(ctx context.Context, req *NewOrderMessage) (*NewOrderMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOrder not implemented")
}
func (*UnimplementedOrderServer) UpdateOrder(ctx context.Context, req *NewOrderMessage) (*NewOrderMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateOrder not implemented")
}
func (*UnimplementedOrderServer) CancelOrder(ctx context.Context, req *NewOrderMessage) (*NewOrderMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelOrder not implemented")
}
func (*UnimplementedOrderServer) PrintOrderbook(ctx context.Context, req *PingMessage) (*OrderBookInfoMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrintOrderbook not implemented")
}

func RegisterOrderServer(s *grpc.Server, srv OrderServer) {
	s.RegisterService(&_Order_serviceDesc, srv)
}

func _Order_AddOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewOrderMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServer).AddOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/orderpb.Order/AddOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServer).AddOrder(ctx, req.(*NewOrderMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Order_GetOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewOrderMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServer).GetOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/orderpb.Order/GetOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServer).GetOrder(ctx, req.(*NewOrderMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Order_UpdateOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewOrderMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServer).UpdateOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/orderpb.Order/UpdateOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServer).UpdateOrder(ctx, req.(*NewOrderMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Order_CancelOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewOrderMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServer).CancelOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/orderpb.Order/CancelOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServer).CancelOrder(ctx, req.(*NewOrderMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Order_PrintOrderbook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrderServer).PrintOrderbook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/orderpb.Order/PrintOrderbook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrderServer).PrintOrderbook(ctx, req.(*PingMessage))
	}
	return interceptor(ctx, in, info, handler)
}

var _Order_serviceDesc = grpc.ServiceDesc{
	ServiceName: "orderpb.Order",
	HandlerType: (*OrderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "addOrder",
			Handler:    _Order_AddOrder_Handler,
		},
		{
			MethodName: "getOrder",
			Handler:    _Order_GetOrder_Handler,
		},
		{
			MethodName: "updateOrder",
			Handler:    _Order_UpdateOrder_Handler,
		},
		{
			MethodName: "cancelOrder",
			Handler:    _Order_CancelOrder_Handler,
		},
		{
			MethodName: "printOrderbook",
			Handler:    _Order_PrintOrderbook_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "order.proto",
}

// PingClient is the client API for Ping service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PingClient interface {
	Ping(ctx context.Context, in *PingMessage, opts ...grpc.CallOption) (*PingMessage, error)
}

type pingClient struct {
	cc grpc.ClientConnInterface
}

func NewPingClient(cc grpc.ClientConnInterface) PingClient {
	return &pingClient{cc}
}

func (c *pingClient) Ping(ctx context.Context, in *PingMessage, opts ...grpc.CallOption) (*PingMessage, error) {
	out := new(PingMessage)
	err := c.cc.Invoke(ctx, "/orderpb.Ping/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PingServer is the server API for Ping service.
type PingServer interface {
	Ping(context.Context, *PingMessage) (*PingMessage, error)
}

// UnimplementedPingServer can be embedded to have forward compatible implementations.
type UnimplementedPingServer struct {
}

func (*UnimplementedPingServer) Ping(ctx context.Context, req *PingMessage) (*PingMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}

func RegisterPingServer(s *grpc.Server, srv PingServer) {
	s.RegisterService(&_Ping_serviceDesc, srv)
}

func _Ping_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PingServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/orderpb.Ping/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PingServer).Ping(ctx, req.(*PingMessage))
	}
	return interceptor(ctx, in, info, handler)
}

var _Ping_serviceDesc = grpc.ServiceDesc{
	ServiceName: "orderpb.Ping",
	HandlerType: (*PingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Ping_Ping_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "order.proto",
}

// GetOrdersClient is the client API for GetOrders service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GetOrdersClient interface {
	GetOrders(ctx context.Context, in *TraderInfoMessage, opts ...grpc.CallOption) (GetOrders_GetOrdersClient, error)
}

type getOrdersClient struct {
	cc grpc.ClientConnInterface
}

func NewGetOrdersClient(cc grpc.ClientConnInterface) GetOrdersClient {
	return &getOrdersClient{cc}
}

func (c *getOrdersClient) GetOrders(ctx context.Context, in *TraderInfoMessage, opts ...grpc.CallOption) (GetOrders_GetOrdersClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GetOrders_serviceDesc.Streams[0], "/orderpb.GetOrders/GetOrders", opts...)
	if err != nil {
		return nil, err
	}
	x := &getOrdersGetOrdersClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GetOrders_GetOrdersClient interface {
	Recv() (*ItemQueryMessage, error)
	grpc.ClientStream
}

type getOrdersGetOrdersClient struct {
	grpc.ClientStream
}

func (x *getOrdersGetOrdersClient) Recv() (*ItemQueryMessage, error) {
	m := new(ItemQueryMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GetOrdersServer is the server API for GetOrders service.
type GetOrdersServer interface {
	GetOrders(*TraderInfoMessage, GetOrders_GetOrdersServer) error
}

// UnimplementedGetOrdersServer can be embedded to have forward compatible implementations.
type UnimplementedGetOrdersServer struct {
}

func (*UnimplementedGetOrdersServer) GetOrders(req *TraderInfoMessage, srv GetOrders_GetOrdersServer) error {
	return status.Errorf(codes.Unimplemented, "method GetOrders not implemented")
}

func RegisterGetOrdersServer(s *grpc.Server, srv GetOrdersServer) {
	s.RegisterService(&_GetOrders_serviceDesc, srv)
}

func _GetOrders_GetOrders_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TraderInfoMessage)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GetOrdersServer).GetOrders(m, &getOrdersGetOrdersServer{stream})
}

type GetOrders_GetOrdersServer interface {
	Send(*ItemQueryMessage) error
	grpc.ServerStream
}

type getOrdersGetOrdersServer struct {
	grpc.ServerStream
}

func (x *getOrdersGetOrdersServer) Send(m *ItemQueryMessage) error {
	return x.ServerStream.SendMsg(m)
}

var _GetOrders_serviceDesc = grpc.ServiceDesc{
	ServiceName: "orderpb.GetOrders",
	HandlerType: (*GetOrdersServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetOrders",
			Handler:       _GetOrders_GetOrders_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "order.proto",
}

// GetOrder2Client is the client API for GetOrder2 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GetOrder2Client interface {
	GetOrder2(ctx context.Context, in *ItemQueryMessage, opts ...grpc.CallOption) (*NewOrderMessage, error)
}

type getOrder2Client struct {
	cc grpc.ClientConnInterface
}

func NewGetOrder2Client(cc grpc.ClientConnInterface) GetOrder2Client {
	return &getOrder2Client{cc}
}

func (c *getOrder2Client) GetOrder2(ctx context.Context, in *ItemQueryMessage, opts ...grpc.CallOption) (*NewOrderMessage, error) {
	out := new(NewOrderMessage)
	err := c.cc.Invoke(ctx, "/orderpb.GetOrder2/GetOrder2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GetOrder2Server is the server API for GetOrder2 service.
type GetOrder2Server interface {
	GetOrder2(context.Context, *ItemQueryMessage) (*NewOrderMessage, error)
}

// UnimplementedGetOrder2Server can be embedded to have forward compatible implementations.
type UnimplementedGetOrder2Server struct {
}

func (*UnimplementedGetOrder2Server) GetOrder2(ctx context.Context, req *ItemQueryMessage) (*NewOrderMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOrder2 not implemented")
}

func RegisterGetOrder2Server(s *grpc.Server, srv GetOrder2Server) {
	s.RegisterService(&_GetOrder2_serviceDesc, srv)
}

func _GetOrder2_GetOrder2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ItemQueryMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GetOrder2Server).GetOrder2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/orderpb.GetOrder2/GetOrder2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GetOrder2Server).GetOrder2(ctx, req.(*ItemQueryMessage))
	}
	return interceptor(ctx, in, info, handler)
}

var _GetOrder2_serviceDesc = grpc.ServiceDesc{
	ServiceName: "orderpb.GetOrder2",
	HandlerType: (*GetOrder2Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOrder2",
			Handler:    _GetOrder2_GetOrder2_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "order.proto",
}

// GetTradesClient is the client API for GetTrades service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GetTradesClient interface {
	GetTrades(ctx context.Context, in *TraderInfoMessage, opts ...grpc.CallOption) (GetTrades_GetTradesClient, error)
}

type getTradesClient struct {
	cc grpc.ClientConnInterface
}

func NewGetTradesClient(cc grpc.ClientConnInterface) GetTradesClient {
	return &getTradesClient{cc}
}

func (c *getTradesClient) GetTrades(ctx context.Context, in *TraderInfoMessage, opts ...grpc.CallOption) (GetTrades_GetTradesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GetTrades_serviceDesc.Streams[0], "/orderpb.GetTrades/GetTrades", opts...)
	if err != nil {
		return nil, err
	}
	x := &getTradesGetTradesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GetTrades_GetTradesClient interface {
	Recv() (*ItemQueryMessage, error)
	grpc.ClientStream
}

type getTradesGetTradesClient struct {
	grpc.ClientStream
}

func (x *getTradesGetTradesClient) Recv() (*ItemQueryMessage, error) {
	m := new(ItemQueryMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GetTradesServer is the server API for GetTrades service.
type GetTradesServer interface {
	GetTrades(*TraderInfoMessage, GetTrades_GetTradesServer) error
}

// UnimplementedGetTradesServer can be embedded to have forward compatible implementations.
type UnimplementedGetTradesServer struct {
}

func (*UnimplementedGetTradesServer) GetTrades(req *TraderInfoMessage, srv GetTrades_GetTradesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetTrades not implemented")
}

func RegisterGetTradesServer(s *grpc.Server, srv GetTradesServer) {
	s.RegisterService(&_GetTrades_serviceDesc, srv)
}

func _GetTrades_GetTrades_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TraderInfoMessage)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GetTradesServer).GetTrades(m, &getTradesGetTradesServer{stream})
}

type GetTrades_GetTradesServer interface {
	Send(*ItemQueryMessage) error
	grpc.ServerStream
}

type getTradesGetTradesServer struct {
	grpc.ServerStream
}

func (x *getTradesGetTradesServer) Send(m *ItemQueryMessage) error {
	return x.ServerStream.SendMsg(m)
}

var _GetTrades_serviceDesc = grpc.ServiceDesc{
	ServiceName: "orderpb.GetTrades",
	HandlerType: (*GetTradesServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetTrades",
			Handler:       _GetTrades_GetTrades_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "order.proto",
}

// GetTradeClient is the client API for GetTrade service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GetTradeClient interface {
	GetTrade(ctx context.Context, in *ItemQueryMessage, opts ...grpc.CallOption) (GetTrade_GetTradeClient, error)
}

type getTradeClient struct {
	cc grpc.ClientConnInterface
}

func NewGetTradeClient(cc grpc.ClientConnInterface) GetTradeClient {
	return &getTradeClient{cc}
}

func (c *getTradeClient) GetTrade(ctx context.Context, in *ItemQueryMessage, opts ...grpc.CallOption) (GetTrade_GetTradeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GetTrade_serviceDesc.Streams[0], "/orderpb.GetTrade/GetTrade", opts...)
	if err != nil {
		return nil, err
	}
	x := &getTradeGetTradeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GetTrade_GetTradeClient interface {
	Recv() (*TradeMessage, error)
	grpc.ClientStream
}

type getTradeGetTradeClient struct {
	grpc.ClientStream
}

func (x *getTradeGetTradeClient) Recv() (*TradeMessage, error) {
	m := new(TradeMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GetTradeServer is the server API for GetTrade service.
type GetTradeServer interface {
	GetTrade(*ItemQueryMessage, GetTrade_GetTradeServer) error
}

// UnimplementedGetTradeServer can be embedded to have forward compatible implementations.
type UnimplementedGetTradeServer struct {
}

func (*UnimplementedGetTradeServer) GetTrade(req *ItemQueryMessage, srv GetTrade_GetTradeServer) error {
	return status.Errorf(codes.Unimplemented, "method GetTrade not implemented")
}

func RegisterGetTradeServer(s *grpc.Server, srv GetTradeServer) {
	s.RegisterService(&_GetTrade_serviceDesc, srv)
}

func _GetTrade_GetTrade_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ItemQueryMessage)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GetTradeServer).GetTrade(m, &getTradeGetTradeServer{stream})
}

type GetTrade_GetTradeServer interface {
	Send(*TradeMessage) error
	grpc.ServerStream
}

type getTradeGetTradeServer struct {
	grpc.ServerStream
}

func (x *getTradeGetTradeServer) Send(m *TradeMessage) error {
	return x.ServerStream.SendMsg(m)
}

var _GetTrade_serviceDesc = grpc.ServiceDesc{
	ServiceName: "orderpb.GetTrade",
	HandlerType: (*GetTradeServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetTrade",
			Handler:       _GetTrade_GetTrade_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "order.proto",
}

// GetMatchedTradesClient is the client API for GetMatchedTrades service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GetMatchedTradesClient interface {
	GetMatchedTrades(ctx context.Context, in *TraderInfoMessage, opts ...grpc.CallOption) (GetMatchedTrades_GetMatchedTradesClient, error)
}

type getMatchedTradesClient struct {
	cc grpc.ClientConnInterface
}

func NewGetMatchedTradesClient(cc grpc.ClientConnInterface) GetMatchedTradesClient {
	return &getMatchedTradesClient{cc}
}

func (c *getMatchedTradesClient) GetMatchedTrades(ctx context.Context, in *TraderInfoMessage, opts ...grpc.CallOption) (GetMatchedTrades_GetMatchedTradesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GetMatchedTrades_serviceDesc.Streams[0], "/orderpb.GetMatchedTrades/GetMatchedTrades", opts...)
	if err != nil {
		return nil, err
	}
	x := &getMatchedTradesGetMatchedTradesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GetMatchedTrades_GetMatchedTradesClient interface {
	Recv() (*ItemQueryMessage, error)
	grpc.ClientStream
}

type getMatchedTradesGetMatchedTradesClient struct {
	grpc.ClientStream
}

func (x *getMatchedTradesGetMatchedTradesClient) Recv() (*ItemQueryMessage, error) {
	m := new(ItemQueryMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GetMatchedTradesServer is the server API for GetMatchedTrades service.
type GetMatchedTradesServer interface {
	GetMatchedTrades(*TraderInfoMessage, GetMatchedTrades_GetMatchedTradesServer) error
}

// UnimplementedGetMatchedTradesServer can be embedded to have forward compatible implementations.
type UnimplementedGetMatchedTradesServer struct {
}

func (*UnimplementedGetMatchedTradesServer) GetMatchedTrades(req *TraderInfoMessage, srv GetMatchedTrades_GetMatchedTradesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetMatchedTrades not implemented")
}

func RegisterGetMatchedTradesServer(s *grpc.Server, srv GetMatchedTradesServer) {
	s.RegisterService(&_GetMatchedTrades_serviceDesc, srv)
}

func _GetMatchedTrades_GetMatchedTrades_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TraderInfoMessage)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GetMatchedTradesServer).GetMatchedTrades(m, &getMatchedTradesGetMatchedTradesServer{stream})
}

type GetMatchedTrades_GetMatchedTradesServer interface {
	Send(*ItemQueryMessage) error
	grpc.ServerStream
}

type getMatchedTradesGetMatchedTradesServer struct {
	grpc.ServerStream
}

func (x *getMatchedTradesGetMatchedTradesServer) Send(m *ItemQueryMessage) error {
	return x.ServerStream.SendMsg(m)
}

var _GetMatchedTrades_serviceDesc = grpc.ServiceDesc{
	ServiceName: "orderpb.GetMatchedTrades",
	HandlerType: (*GetMatchedTradesServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetMatchedTrades",
			Handler:       _GetMatchedTrades_GetMatchedTrades_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "order.proto",
}

// GetTradeMatchClient is the client API for GetTradeMatch service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GetTradeMatchClient interface {
	GetTradeMatch(ctx context.Context, in *ItemQueryMessage, opts ...grpc.CallOption) (GetTradeMatch_GetTradeMatchClient, error)
}

type getTradeMatchClient struct {
	cc grpc.ClientConnInterface
}

func NewGetTradeMatchClient(cc grpc.ClientConnInterface) GetTradeMatchClient {
	return &getTradeMatchClient{cc}
}

func (c *getTradeMatchClient) GetTradeMatch(ctx context.Context, in *ItemQueryMessage, opts ...grpc.CallOption) (GetTradeMatch_GetTradeMatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &_GetTradeMatch_serviceDesc.Streams[0], "/orderpb.GetTradeMatch/GetTradeMatch", opts...)
	if err != nil {
		return nil, err
	}
	x := &getTradeMatchGetTradeMatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GetTradeMatch_GetTradeMatchClient interface {
	Recv() (*TradeMatchingMessage, error)
	grpc.ClientStream
}

type getTradeMatchGetTradeMatchClient struct {
	grpc.ClientStream
}

func (x *getTradeMatchGetTradeMatchClient) Recv() (*TradeMatchingMessage, error) {
	m := new(TradeMatchingMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GetTradeMatchServer is the server API for GetTradeMatch service.
type GetTradeMatchServer interface {
	GetTradeMatch(*ItemQueryMessage, GetTradeMatch_GetTradeMatchServer) error
}

// UnimplementedGetTradeMatchServer can be embedded to have forward compatible implementations.
type UnimplementedGetTradeMatchServer struct {
}

func (*UnimplementedGetTradeMatchServer) GetTradeMatch(req *ItemQueryMessage, srv GetTradeMatch_GetTradeMatchServer) error {
	return status.Errorf(codes.Unimplemented, "method GetTradeMatch not implemented")
}

func RegisterGetTradeMatchServer(s *grpc.Server, srv GetTradeMatchServer) {
	s.RegisterService(&_GetTradeMatch_serviceDesc, srv)
}

func _GetTradeMatch_GetTradeMatch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ItemQueryMessage)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GetTradeMatchServer).GetTradeMatch(m, &getTradeMatchGetTradeMatchServer{stream})
}

type GetTradeMatch_GetTradeMatchServer interface {
	Send(*TradeMatchingMessage) error
	grpc.ServerStream
}

type getTradeMatchGetTradeMatchServer struct {
	grpc.ServerStream
}

func (x *getTradeMatchGetTradeMatchServer) Send(m *TradeMatchingMessage) error {
	return x.ServerStream.SendMsg(m)
}

var _GetTradeMatch_serviceDesc = grpc.ServiceDesc{
	ServiceName: "orderpb.GetTradeMatch",
	HandlerType: (*GetTradeMatchServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetTradeMatch",
			Handler:       _GetTradeMatch_GetTradeMatch_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "order.proto",
}
